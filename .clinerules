# Cline Rules for UrbanAI

You are Cline working in the UrbanAI repository. Follow these rules exactly.

## Memory Bank: REQUIRED BEHAVIOR

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Context Window Management: CRITICAL PROTOCOL

Monitor context window usage continuously throughout every session. When context reaches 70-80% capacity:

1. **STOP** current work immediately
2. **UPDATE** Memory Bank with current progress and findings
3. **CREATE** new task thread using the `new_task` tool with comprehensive context transfer
4. **TRANSFER** all critical information including:
   - Current work status and next steps
   - Technical details and decisions made
   - File changes and pending tasks
   - Direct quotes from recent user interactions
   - Exact specifications and requirements

This prevents context overflow and information loss between sessions. Context management is as critical as the Memory Bank workflow itself.

### Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]

Core files (must exist in memory-bank/ and be read at task start):
1. projectbrief.md
2. productContext.md
3. activeContext.md
4. systemPatterns.md
5. techContext.md
6. progress.md

Additional context files may be added within memory-bank/ for features, integrations, testing, deployment, etc.

### Core Workflows

Plan Mode:
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}
    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]
    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]

Act Mode:
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Execute[Execute Task]
    Execute --> Document[Document Changes]

### Documentation Updates

Update Memory Bank when:
1) discovering new patterns,
2) after significant changes,
3) when the user requests “update memory bank” (review ALL files),
4) when context needs clarification.

Process:
- Review ALL files
- Document current state
- Clarify next steps
- Capture insights & patterns

REMEMBER: After every reset, begin fresh. The Memory Bank is the only link to previous work; maintain it with precision.

## UrbanAI Project Conventions

- Architecture: Clean Architecture with layers
  - UrbanAI.API (entrypoint)
  - UrbanAI.Application (use cases, DTOs, services)
  - UrbanAI.Domain (entities, interfaces)
  - UrbanAI.Infrastructure (EF Core, MongoDB, repos)
- Data:
  - Relational DB via EF Core (see Migrations) and ApplicationDbContext
  - MongoDB for regulation documents (MongoDbContext/MongoDbSettings)
- API:
  - REST endpoints (see docs/api/openapi.yaml). Example: /v1/issues (Create/Read/Update)
  - Controllers map DTOs to Domain entities via Application services
- Frontend:
  - Vite + React + TypeScript at src/UrbanAI.Frontend
  - Do not commit build artifacts (dist) — respect .clineignore
- CI:
  - Azure Pipelines at azure-pipelines.yml builds/tests with coverage
- Tests:
  - tests/* projects for unit/integration coverage
- Git:
  - main and develop branches exist; prefer PRs; avoid force pushes

## Frontend UI Validation: MANDATORY PROTOCOL

**CRITICAL REQUIREMENT**: ALL frontend/UI changes MUST be validated using embedded browser testing before completion.

### Browser Validation Workflow
For ANY change to HTML, CSS, or frontend assets:

1. **IMPLEMENT** the changes to frontend files
2. **LAUNCH** embedded browser using `browser_action` tool
3. **NAVIGATE** to modified pages/components
4. **CAPTURE** screenshots for visual verification
5. **TEST** interactive elements (hover, focus, click states)
6. **VERIFY** responsive behavior across screen sizes
7. **DOCUMENT** validation results
8. **CLOSE** browser before proceeding to other tools

### Validation Requirements
- ✅ Visual elements display correctly
- ✅ Brand assets appear as intended  
- ✅ Interactive states work properly
- ✅ Responsive design functions across screen sizes
- ✅ Accessibility features are functional
- ✅ No console errors or warnings

### Non-Negotiable Rules
- **NO COMPLETION** of frontend tasks without browser validation
- **NO MERGE** of UI changes without documented testing
- **ALWAYS** test before marking tasks complete
- **DOCUMENT** any visual discrepancies or issues found

This protocol ensures UI quality and prevents visual regressions across all UrbanAI interfaces.

## Testing Policies: MANDATORY REQUIREMENTS

**CRITICAL REQUIREMENT**: ALL code changes MUST include comprehensive testing before completion.

### Testing Framework Standards
- **React Unit Tests**: React Testing Library + Vitest (minimum 80% coverage)
- **Backend Unit Tests**: xUnit + Moq (minimum 80% coverage)
- **E2E Browser Tests**: Playwright (cross-browser: Chrome, Firefox, Safari, Mobile)
- **Integration Tests**: Custom WebApplicationFactory for API testing

### Mandatory Testing Workflow
For ANY code change (frontend or backend):

1. **IMPLEMENT** the code changes
2. **CREATE** corresponding unit tests
3. **RUN** unit tests and verify 80%+ coverage
4. **CREATE** integration/E2E tests if applicable
5. **RUN** full test suite and verify all tests pass
6. **UPDATE** existing tests if functionality changed
7. **DOCUMENT** test results and coverage metrics

### Testing Requirements Checklist
- ✅ Unit tests created for new components/services
- ✅ Unit tests updated for modified components/services
- ✅ Integration tests created for new API endpoints
- ✅ E2E tests created for new user flows
- ✅ All tests pass without errors
- ✅ Coverage thresholds met (80% minimum)
- ✅ Accessibility testing included for UI components
- ✅ Responsive design testing for mobile/desktop

### Non-Negotiable Testing Rules
- **NO COMPLETION** of tasks without comprehensive test coverage
- **NO MERGE** of code changes without passing tests
- **ALWAYS** update tests when fixing bugs
- **MANDATORY** test creation for OAuth, authentication, and security features
- **REQUIRED** browser testing for all UI changes
- **ENFORCE** 80% minimum coverage thresholds

### Test Organization Standards
- React tests: `src/components/__tests__/ComponentName.test.tsx`
- E2E tests: `tests/e2e/feature-name.spec.ts`
- Backend tests: `tests/ProjectName.Tests/ServiceTests.cs`
- Test utilities: `src/test/` for React, `tests/Shared/` for backend

### Post-Completion Testing Policy
After completing any feature implementation:
1. **FULL TEST SUITE EXECUTION**: Run all unit, integration, and E2E tests
2. **COVERAGE VERIFICATION**: Ensure 80%+ coverage across all test types
3. **BROWSER VALIDATION**: Validate UI changes in embedded browser testing
4. **MEMORY BANK UPDATE**: Document completed implementation and test results
5. **SECURITY REVIEW**: Verify OAuth flows and authentication mechanisms
6. **ACCESSIBILITY CHECK**: Confirm WCAG compliance for new UI components

This ensures code quality, prevents regressions, and maintains system reliability across all UrbanAI development.

## Tooling & Safety

- Shell: Windows (cmd.exe). Prefer project-root commands.
- Destructive actions (delete, re-init, secrets) require explicit confirmation.
- Use VS Code integrated terminal and respect repository paths.
- Follow .clineignore for read/write/search scope.

## Auto-Approve Preferences (recommended)

- Allow reading project files automatically.
- Ask before editing files, executing commands, or using external tools.
- Set a reasonable max automated requests per session.

## Project Sources of Truth

- memory-bank/*.md
- docs/ (architecture diagrams, sequence diagrams, figma)
- src/ (API/Application/Domain/Infrastructure)
- azure-pipelines.yml
- docs/api/openapi.yaml

At task start:
1) Read memory-bank core files,
2) Skim relevant docs/* files for the area of work,
3) Confirm understanding in Plan Mode before acting.
