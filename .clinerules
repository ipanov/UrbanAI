# Cline Rules for UrbanAI

You are Cline working in the UrbanAI repository. Follow these rules exactly.

## Memory Bank: REQUIRED BEHAVIOR

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Context Window Management: CRITICAL PROTOCOL

Monitor context window usage continuously throughout every session. When context reaches 70-80% capacity:

1. **STOP** current work immediately
2. **UPDATE** Memory Bank with current progress and findings
3. **CREATE** new task thread using the `new_task` tool with comprehensive context transfer
4. **TRANSFER** all critical information including:
   - Current work status and next steps
   - Technical details and decisions made
   - File changes and pending tasks
   - Direct quotes from recent user interactions
   - Exact specifications and requirements

This prevents context overflow and information loss between sessions. Context management is as critical as the Memory Bank workflow itself.

### Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]

Core files (must exist in memory-bank/ and be read at task start):
1. projectbrief.md
2. productContext.md
3. activeContext.md
4. systemPatterns.md
5. techContext.md
6. progress.md

Additional context files may be added within memory-bank/ for features, integrations, testing, deployment, etc.

### Core Workflows

Plan Mode:
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}
    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]
    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]

Act Mode:
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Execute[Execute Task]
    Execute --> Document[Document Changes]

### Documentation Updates

Update Memory Bank when:
1) discovering new patterns,
2) after significant changes,
3) when the user requests “update memory bank” (review ALL files),
4) when context needs clarification.

Process:
- Review ALL files
- Document current state
- Clarify next steps
- Capture insights & patterns

REMEMBER: After every reset, begin fresh. The Memory Bank is the only link to previous work; maintain it with precision.

## UrbanAI Project Conventions

- Architecture: Clean Architecture with layers
  - UrbanAI.API (entrypoint)
  - UrbanAI.Application (use cases, DTOs, services)
  - UrbanAI.Domain (entities, interfaces)
  - UrbanAI.Infrastructure (EF Core, MongoDB, repos)
- Data:
  - Relational DB via EF Core (see Migrations) and ApplicationDbContext
  - MongoDB for regulation documents (MongoDbContext/MongoDbSettings)
- API:
  - REST endpoints (see docs/api/openapi.yaml). Example: /v1/issues (Create/Read/Update)
  - Controllers map DTOs to Domain entities via Application services
- Frontend:
  - Vite + React + TypeScript at src/UrbanAI.Frontend
  - Do not commit build artifacts (dist) — respect .clineignore
- CI:
  - Azure Pipelines at azure-pipelines.yml builds/tests with coverage
- Tests:
  - tests/* projects for unit/integration coverage
- Git:
  - main and develop branches exist; prefer PRs; avoid force pushes

## Frontend UI Validation: MANDATORY PROTOCOL

**CRITICAL REQUIREMENT**: ALL frontend/UI changes MUST be validated using embedded browser testing before completion.

### Browser Validation Workflow
For ANY change to HTML, CSS, or frontend assets:

1. **IMPLEMENT** the changes to frontend files
2. **LAUNCH** embedded browser using `browser_action` tool
3. **NAVIGATE** to modified pages/components
4. **CAPTURE** screenshots for visual verification
5. **TEST** interactive elements (hover, focus, click states)
6. **VERIFY** responsive behavior across screen sizes
7. **DOCUMENT** validation results
8. **CLOSE** browser before proceeding to other tools

### Validation Requirements
- ✅ Visual elements display correctly
- ✅ Brand assets appear as intended  
- ✅ Interactive states work properly
- ✅ Responsive design functions across screen sizes
- ✅ Accessibility features are functional
- ✅ No console errors or warnings

### Non-Negotiable Rules
- **NO COMPLETION** of frontend tasks without browser validation
- **NO MERGE** of UI changes without documented testing
- **ALWAYS** test before marking tasks complete
- **DOCUMENT** any visual discrepancies or issues found

This protocol ensures UI quality and prevents visual regressions across all UrbanAI interfaces.

## Testing Policies: MANDATORY REQUIREMENTS

**CRITICAL REQUIREMENT**: ALL code changes MUST include comprehensive testing before completion.

### Testing Framework Standards
- **React Unit Tests**: React Testing Library + Vitest (minimum 80% coverage)
- **Backend Unit Tests**: xUnit + Moq (minimum 80% coverage)
- **E2E Browser Tests**: Playwright (cross-browser: Chrome, Firefox, Safari, Mobile)
- **Integration Tests**: Custom WebApplicationFactory for API testing

### Mandatory Testing Workflow
For ANY code change (frontend or backend):

1. **IMPLEMENT** the code changes
2. **CREATE** corresponding unit tests
3. **RUN** unit tests and verify 80%+ coverage
4. **CREATE** integration/E2E tests if applicable
5. **RUN** full test suite and verify all tests pass
6. **UPDATE** existing tests if functionality changed
7. **DOCUMENT** test results and coverage metrics

### Testing Requirements Checklist
- ✅ Unit tests created for new components/services
- ✅ Unit tests updated for modified components/services
- ✅ Integration tests created for new API endpoints
- ✅ E2E tests created for new user flows
- ✅ All tests pass without errors
- ✅ Coverage thresholds met (80% minimum)
- ✅ Accessibility testing included for UI components
- ✅ Responsive design testing for mobile/desktop

### Non-Negotiable Testing Rules
- **NO COMPLETION** of tasks without comprehensive test coverage
- **NO MERGE** of code changes without passing tests
- **ALWAYS** update tests when fixing bugs
- **MANDATORY** test creation for OAuth, authentication, and security features
- **REQUIRED** browser testing for all UI changes
- **ENFORCE** 80% minimum coverage thresholds

### Test Organization Standards
- React tests: `src/components/__tests__/ComponentName.test.tsx`
- E2E tests: `tests/e2e/feature-name.spec.ts`
- Backend tests: `tests/ProjectName.Tests/ServiceTests.cs`
- Test utilities: `src/test/` for React, `tests/Shared/` for backend

### Post-Completion Testing Policy
After completing any feature implementation:
1. **FULL TEST SUITE EXECUTION**: Run all unit, integration, and E2E tests
2. **COVERAGE VERIFICATION**: Ensure 80%+ coverage across all test types
3. **BROWSER VALIDATION**: Validate UI changes in embedded browser testing
4. **MEMORY BANK UPDATE**: Document completed implementation and test results
5. **SECURITY REVIEW**: Verify OAuth flows and authentication mechanisms
6. **ACCESSIBILITY CHECK**: Confirm WCAG compliance for new UI components

This ensures code quality, prevents regressions, and maintains system reliability across all UrbanAI development.

## Process Management: MANDATORY PROTOCOL

**CRITICAL REQUIREMENT**: ALWAYS kill existing processes before starting HTTP applications to ensure consistent port usage.

### Process Cleanup Workflow
Before starting ANY HTTP server (API, React, etc.):

1. **IDENTIFY** target ports (API: 5001, React: 3000, etc.)
2. **KILL** existing processes on those ports
3. **VERIFY** ports are free before starting new processes
4. **START** applications with consistent port assignments

### Standard Port Assignments
- **API**: http://localhost:5001 (ASP.NET Core)
- **React Frontend**: http://localhost:3000 (Vite dev server)
- **Test Services**: http://localhost:8080+ (avoid conflicts)

### Process Kill Commands (Windows)
```cmd
# Kill processes on specific ports
netstat -ano | findstr :5001 | for /f "tokens=5" %a in ('more') do taskkill /f /pid %a
netstat -ano | findstr :3000 | for /f "tokens=5" %a in ('more') do taskkill /f /pid %a

# Alternative: Kill all Node.js processes
taskkill /f /im node.exe
```

### Non-Negotiable Rules
- **NO STARTING** applications without killing existing processes
- **ALWAYS** use consistent port assignments across sessions
- **VERIFY** port availability before application startup
- **DOCUMENT** any port conflicts or issues encountered

This ensures reliable application startup and prevents port conflicts across development sessions.

## Tooling & Safety

- Shell: Windows (cmd.exe). Prefer project-root commands.
- Destructive actions (delete, re-init, secrets) require explicit confirmation.
- Use VS Code integrated terminal and respect repository paths.
- Follow .clineignore for read/write/search scope.

## Auto-Approve Preferences (recommended)

- Allow reading project files automatically.
- Ask before editing files, executing commands, or using external tools.
- Set a reasonable max automated requests per session.

## Project Sources of Truth

- memory-bank/*.md
- docs/ (architecture diagrams, sequence diagrams, figma)
- src/ (API/Application/Domain/Infrastructure)
- azure-pipelines.yml
- docs/api/openapi.yaml

## CI/CD Enforcement (UrbanAI additions)
These rules extend Cline's mandatory behavior specifically for CI/CD to ensure a closed-loop feedback and remediation process.

1. Build Triggering Policy
   - Full release pipelines (build + tests + coverage + deploy) MUST run only on merges to `main`.
   - Lightweight or selective CI may run on `develop` (configured in .github/workflows/ci.yml) and PRs, but MUST avoid running expensive full-suite builds on every push to `develop`.

2. Coverage & Reporting
   - All release runs MUST upload artifacts: test results, coverage reports, and any build logs to the workflow artifacts store.
   - Coverage threshold enforcement happens in the release pipeline; Cline MUST block task completion if coverage verification fails.

3. Failure Handling & Self-Healing Loop
   - If a release pipeline run results in FAILURE:
     - Cline MUST retrieve logs and relevant artifacts via the GitHub MCP server (`get_workflow_run`, `get_job_logs`, `list_workflow_runs`).
     - Cline MUST create a GitHub Issue titled "[CI FAILURE] <workflow> failed on <branch> — run <id>", include logs/artifact links, label it `ci-failure` and `urgent`, and assign it to the repository owner by default.
     - Cline MUST open a new task thread (using `new_task`) that contains:
       - Issue link and number
       - The failing workflow run id and step logs
       - Suggested next steps and the minimal reproduction commands
     - Cline MUST iterate: attempt fixes (or propose fixes), push changes, and monitor the next run via MCP until the workflow completes successfully.
     - The task is only closed when MCP confirms the workflow run status is `success`.

4. Assignment Logic
   - Default assignee is the repository owner.
   - If the failing step clearly maps to a subsystem (frontend vs backend vs infra), Cline SHOULD prefer assigning to the subsystem owner if configured. If no mapping exists, assign to repository owner.

5. Notifications & PR Feedback
   - On failure, Cline MUST post the summary and artifact links to the related PR and the created issue.
   - On success, Cline MUST post a final comment indicating pass + coverage delta (if available), and then close the task.

6. Safety and Limits
   - Do not automatically close issues created for CI failures until the pipeline passes.
   - For destructive remediation changes, seek human approval (explicit confirmation) before applying.
   - Respect `.clineignore` and never attach/distribute binary artifacts excluded by policy.

At task start:
1) Read memory-bank core files,
2) Skim relevant docs/* files for the area of work,
3) Confirm understanding in Plan Mode before acting.
