name: UrbanAI CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'src/UrbanAI.Functions'
  DOTNET_VERSION: '9.0.x'
  NODE_VERSION: '20'

jobs:
  comprehensive-tests:
    name: Comprehensive Test Suite
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      # PostgreSQL service for integration tests
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: urbanai_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Backend setup and tests
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore .NET dependencies
      run: dotnet restore UrbanAI.sln
    
    - name: Build solution
      run: dotnet build UrbanAI.sln --configuration Release --no-restore
    
    - name: Run Domain Unit Tests
      run: dotnet test tests/UrbanAI.Domain.Tests/ --configuration Release --no-build --collect:"XPlat Code Coverage" --settings coverlet.runsettings --logger trx --results-directory TestResults/Domain
    
    - name: Run Application Unit Tests
      run: dotnet test tests/UrbanAI.Application.Tests/ --configuration Release --no-build --collect:"XPlat Code Coverage" --settings coverlet.runsettings --logger trx --results-directory TestResults/Application
    
    - name: Run Infrastructure Unit Tests
      run: dotnet test tests/UrbanAI.Infrastructure.Tests/ --configuration Release --no-build --collect:"XPlat Code Coverage" --settings coverlet.runsettings --logger trx --results-directory TestResults/Infrastructure
    
    - name: Run API Unit Tests
      run: dotnet test tests/UrbanAI.API.Tests/ --configuration Release --no-build --collect:"XPlat Code Coverage" --settings coverlet.runsettings --logger trx --results-directory TestResults/API
    
    - name: Run API Integration Tests
      env:
        ASPNETCORE_ENVIRONMENT: Testing
        ConnectionStrings__DefaultConnection: Host=localhost;Port=5432;Database=urbanai_test;Username=postgres;Password=postgres
      run: dotnet test tests/UrbanAI.API.IntegrationTests/ --configuration Release --no-build --collect:"XPlat Code Coverage" --settings integration-coverage.runsettings --logger trx --results-directory TestResults/Integration

    # Frontend setup and tests
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: src/UrbanAI.Frontend/package-lock.json
    
    - name: Install frontend dependencies
      working-directory: src/UrbanAI.Frontend
      run: npm ci
    
    - name: TypeScript compilation check
      working-directory: src/UrbanAI.Frontend
      run: npm run type-check
    
    - name: ESLint code quality check
      working-directory: src/UrbanAI.Frontend
      run: npm run lint
    
    - name: Run frontend unit tests
      working-directory: src/UrbanAI.Frontend
      run: npm run test:coverage
    
    # Check if frontend files have changed (for E2E tests)
    - name: Check for frontend changes
      id: frontend-changes
      uses: dorny/paths-filter@v2
      with:
        filters: |
          frontend:
            - 'src/UrbanAI.Frontend/**'
            - '!src/UrbanAI.Frontend/tests/e2e/**'
            - '!**/*.md'
    
    # E2E tests only run when frontend changes are detected OR it's a PR to main
    - name: Install Playwright
      if: steps.frontend-changes.outputs.frontend == 'true' || github.event_name == 'pull_request'
      working-directory: src/UrbanAI.Frontend
      run: npx playwright install --with-deps
    
    - name: Run E2E tests
      if: steps.frontend-changes.outputs.frontend == 'true' || github.event_name == 'pull_request'
      working-directory: src/UrbanAI.Frontend
      run: npm run test:e2e:ci
      env:
        CI: true
    
    - name: Upload E2E test results
      if: (steps.frontend-changes.outputs.frontend == 'true' || github.event_name == 'pull_request') && always()
      uses: actions/upload-artifact@v4
      with:
        name: playwright-report
        path: src/UrbanAI.Frontend/playwright-report/
        retention-days: 30
    
    # Build frontend for deployment
    - name: Build frontend
      working-directory: src/UrbanAI.Frontend
      run: npm run build
    
    # Coverage reporting
    - name: Install ReportGenerator
      run: dotnet tool install --global dotnet-reportgenerator-globaltool
    
    - name: Generate coverage report
      run: |
        reportgenerator \
          -reports:"TestResults/**/coverage.cobertura.xml" \
          -targetdir:"coverage-report" \
          -reporttypes:"Html;Cobertura;TextSummary" \
          -verbosity:"Info"
    
    - name: Upload coverage report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage-report

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: TestResults

  deploy-production:
    needs: comprehensive-tests
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Deploy infrastructure
      run: azd up -e production --no-prompt

    - name: Build and deploy Functions
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        dotnet build --configuration Release
        dotnet publish --configuration Release --output ./output
        
    - name: Deploy to Azure Functions
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
        package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output'

    - name: Build and deploy Frontend
      working-directory: src/UrbanAI.Frontend
      run: |
        npm ci
        npm run build
        
    - name: Deploy Frontend to Static Web App
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "src/UrbanAI.Frontend/dist"
        skip_api_build: true

  security-scan:
    needs: comprehensive-tests
    runs-on: ubuntu-latest
    steps:
    - name: OWASP ZAP Scan
      uses: zaproxy/action-full-scan@v0.6.0
      with:
        target: 'https://staging.urbanai.site'

  report-failure:
    needs: comprehensive-tests
    if: ${{ needs.comprehensive-tests.result == 'failure' }}
    runs-on: ubuntu-latest
    steps:
    - name: Create GitHub Issue for CI Failure and dispatch event
      uses: actions/github-script@v6
      with:
        script: |
          const issueTitle = `[CI FAILURE] Build failed on ${process.env.GITHUB_REF} â€” run ${process.env.GITHUB_RUN_ID}`;
          const body = `The build/test job failed.\n\nRun: ${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}\n\nArtifacts (if available): coverage-report, test-results\n\nPlease triage.`;
          // Create the issue
          const created = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueTitle,
            body: body,
            labels: ['ci-failure','urgent'],
            assignees: [context.repo.owner]
          });

          // Dispatch a repository event so the listener workflow can react in real-time
          await github.rest.repos.createDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            event_type: 'ci_failure_report',
            client_payload: {
              run_id: process.env.GITHUB_RUN_ID,
              run_url: `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`,
              issue_number: created.data.number,
              issue_url: created.data.html_url,
              branch: process.env.GITHUB_REF
            }
          });

          core.setOutput('issue_number', created.data.number);
